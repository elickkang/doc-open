- ***并发概念***

  ​	计算机是***完成计算任务的机器***，为了屏蔽底层复杂的硬件逻辑，出现了操作系统的概念。操作系统中一个核心功能是进程管理，进程管理允许单核计算机以共享时间片的形式并行执行多个任务，随着硬件的发展、多核CPU的出现，真正的并行时代到来。（多核、多总线、多网卡、多磁盘）

  ​	***进程管理***允许多个任务以并行的方式共享计算机资源，对于每个进程而言，抽象的认为它拥有计算机所有的资源使用权限，包括CPU，内存，磁盘，及网络，这个概念就是***进程是资源分配的基本单位***。由此看来进程是重量级的，不够轻量，每创建一个进程都需要维护很多的资源元数据，并带来进程调度消耗。***线程调度***又被称为轻量级进程，一个进程可以拥有多个线程，并且多个线程共享内存空间，（每个线程也有私有栈空间）。***线程是调度的基本单元***。下文的讨论基于线程调度进行。

  

- ***并发安全***

  ​	多线程可以充分利用系统资源，避免资源浪费，而且满足了事务同时执行的需求。多线程共享进程的内存空间，由此带来了线程安全问题，不加以注意会导致严重的程序逻辑错误或者系统错误。常用的并发安全方式是基于锁机制

  - **硬件层面**

    - 锁主线
    - 锁缓存

  - **操作系统为了解决线程安全问题提供了诸多机制**

    - 长轮询
    - PV操作
    - 互斥量、信号量
    - 管程

  - **不同的编程语言基于此又提供了更方便的线程同步机制，以Java为例子**

    - synchronized
    - Lock配合 wait()、notify()、notifyAll() 使用
    -  Semaphore  、Condition、CountDownLatch、CyclicBarrier等

  - **编程语言基于这些机制又提供了更为安全和方便的线程安全数据结构**

    - Vector

    - HashTable

    - java.util.concurrent集合(ConcurrentHashMap、CopyOnWriteArrayList(可并发读)[^1]、CopyOnWriteArraySet(可并发读) [^1]，ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque、LinkedBlockingDeque )

    - Collections包装方法

      ```java
      List<E> synArrayList = Collections.synchronizedList(new ArrayList<E>());
      
      Set<E> synHashSet = Collections.synchronizedSet(new HashSet<E>());
      
      Map<K,V> synHashMap = Collections.synchronizedMap(new HashMap<K,V>());
      ```

    [^1]: 为什么不允许并发写？（多线程并发写会造成数据覆盖，造成不可避免的线程安全问题）

    

- ***数据库中的并发（mysql）***

  - **数据库引擎**

    - *myisam*

      - 不支持事务
      - 不支持外键
      - 非聚集索引，索引和数据分离，索引保存的是数据文件的指针，主键索引和辅助索引是独立的
      - select count(1) from table执行迅速，因为使用一个变量保存了整个表的行数
      - 支持全文索引
      - 可以进行表压缩，节省磁盘空间
      - 支持表级锁
      - 并发性能差
      - 不一定有主键
      - 三种文件，frm:表定义文件，myd:数据文件,myi：索引文件
      - 5.5之前默认引擎
      
    - *innodb*
    
      - 支持事务
    
      - 支持外键
    
      - 拥有唯一聚集索引，数据和主键索引绑定到一起；其他索引是非聚集索引，单一辅助索引需要进行两次查询，先查询到主键，然后根据主键查询到数据
    
      - 覆盖索引，组合索引中如果查询的字段包含在组合索引中，则只需要一次查询而不需要先查到主键再查到数据
    
      - select count(1) from table查询速度慢
    
      - 支持行级别锁、间隙锁、next-key lock
    
      - 并发性能优
    
      - 一定会有主键，如果没有则默认生成一个
    
      - 两种文件，frm:表定义文件，ibd:数据文件
    
      - 5.5之后默认引擎
    
        
    
    |                  | myisam                        | innodb                        |
    | ---------------- | ----------------------------- | ----------------------------- |
    | 是否支持事务     | :negative_squared_cross_mark: | :ok_hand:                     |
    | 是否支持外键     | :negative_squared_cross_mark: | :ok_hand:                     |
    | 索引类型         | 非聚集索引                    | 聚集索引，覆盖索引            |
    | 是否存有表行数   | :ok_hand:                     | :negative_squared_cross_mark: |
    | 锁类型           | 表锁                          | 行锁、间隙锁、next-key锁等    |
    | 并发性能         | 差                            | 好                            |
    | 是否必须有主键   | 否                            | 是                            |
    | 是否支持全文索引 | 是                            | \>5.7                         |
    | 默认引擎         | <5.5                          | \>5.5                         |
    
    
    
  - **事务**
  
    ​	每个事务需要一个线程执行，不同的事务需要不同的线程执行；如何评价一个数据库事务支持的优劣呢，A(原子性)、C(一致性)、I(隔离性)、D(持久性)。一个良好的数据库在能支持良好事务的前提下，还能够提供较好的并发性能——(支持并发事务多、响应事务时间短、处理事务能力强)。mysql 的innodb引擎就是这样一款数据库引擎。
  
    - *ACID*
  
      - A(atomicity) 原子性
  
        一个事务要么执行成功，要么执行失败，不允许有中间状态；如果事务执行失败，需要回滚到事务开始前的状态，通常使用日志来实现
  
      - C(consistency) 一致性
  
        数据一致性，无论数据库并发执行多少事务，都应该保证数据一致性，可以用零和博弈的概念辅助理解，通常使用各种锁来实现
  
      - I(isolation) 隔离性
  
        数据库并发执行多个事务的同时，各个事务内部对外部事务无感知，即各个事务之间互不影响，可以用多进程概念中每个进程都认为自己独占了计算机来辅助理解，通常使用各种锁来实现
  
      - D(Durability) 持久化
  
        事务对数据库做的变更需要永久的保存到数据库中，不会出现未持久到磁盘这种情况，数据库通常使用日志(redo重做——向前滚动恢复、undo撤销——向后滚动恢复)来保证持久化
  
    - *事务隔离级别*
  
      ​	事务隔离级别反映了数据库支持ACID隔离性的优劣，同时不同的隔离级别往往也预示着不同的并发性能，
  
      数据库都是在这两者之间做权衡。***优秀的数据库总能够兼顾ACID和性能***，比如MYSQL INNODB，默认隔离级别是READ REPEAT(可重复读),同时还能够避免幻读，但是依旧能够提供较好的并发性能。
  
      | 隔离级别         | 中文释义 | 并发性能                             | 隔离性问题 | 锁类型                    |
      | ---------------- | -------- | ------------------------------------ | ---------- | ------------------------- |
      | serializable     | 串行化   | :ok_hand:                            | 无         | 表锁                      |
      | Repeatable read  | 可重复读 | :ok_hand::ok_hand:                   | 幻读[^2]   | 行锁、间隙锁避免幻读;[^2] |
      | Read committed   | 读提交   | :ok_hand::ok_hand::ok_hand:          | 不可重复读 | 行锁                      |
      | Read uncommitted | 读未提交 | :ok_hand::ok_hand::ok_hand::ok_hand: | 脏读       | 无                        |
  
    - *MVCC*
  
      ​	Multi-Version Concurrency Control ，多版本并发控制，mysql默认隔离级别是Repeatable read，mysql充分运用锁机制 满足可重复读以及避免了幻读，但是也丧失了良好的性能，鉴于此mysql运用MVCC机制极大的提升了mysql的性能，MVCC主要是为了提升MYSQL的查询性能而做的优化，但是不要指望MVCC可以完全替代锁机制而能完美解决并发安全问题
  
      ​	MVCC对每张表都新增了两个虚拟字段——新增版本号、删除版本号；
  
      - 当执行新增的时候，会将当前事务号设置到新增版本号中
      - 当删除的时候会将当前事务号设置到删除版本号
      - 当更新的时候会分为两个步骤进行；讲当前事务号设置为删除版本号，新增一行，并将当前事务号设置为新增版本号
      - ***当查询的时候，会查询小于等于新增版本号，大于等于删除版本号的数据***，从而避免不可重复读和幻读
  
    - 事务死锁隐患
  
      MVCC在读的时候允许写，写的时候允许读，并能保证良好的隔离性；***但是对于并发写、删除、改操作，则会上升为锁机制，操作不当极容易引起死锁***
  
      - 写写操作
  
        ​	表中设置了唯一性索引，在insert的时候如果***多个事务操作同一个主键对应的记录***则会锁升级，容易产生死锁,如果是非唯一性索引则不会有问题，或者如果是mysql设置了自增主键，新增的时候不指定主键也不会有问题。***比较好的习惯是新增一个业务无关唯一性主键，并设置自增，其他字段如果需要则设置为非唯一索引***
  
      - 写删操作
  
        ​	不管表中是否设置了索引，新增之后删除都极易造成锁升级，避免这种操作
  
    
  
- ***结语***

  ​	由此看来，世事难两全，为了提升系统性能引入了多线程技术（并发技术），但同时也带来了线程安全问题，为了防范安全问题引入了锁机制，而锁机制又不可避免的降低了系统性能。MVCC和锁的相互配合就是MYSQL在性能和事务安全做的效益最大化方案，但牢记并没有任何情况下的最优方案。

  ​	单机并发的安全实现主要依赖于锁机制，而为了减少锁带来的性能消耗又出现了一些其他机制：诸如MVCC这种快照协议（空间换时间的策略）以及CAS(compare and set)这种乐观锁机制

  [^2]: mysql有快照读和当前读，快照读是依赖MVCC避免幻读（通过新增两个虚拟字段——新增版本号，删除版本号），而当前读则是依赖next-key锁避免幻读

  